// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.
// Licensed under the Apache License, Version 2.0.
// See LICENSE in the project root for license information.

/* eslint-disable no-underscore-dangle */
import { UserManager, WebStorageStateStore } from 'oidc-client';
import { uuid4RFC4122 } from '@misakey/helpers/uuid4';
import log from '@misakey/helpers/log';
import logSentryException from '@misakey/helpers/log/sentry/exception';
import isNil from '@misakey/helpers/isNil';
import storage, { StorageUnavailable } from '@misakey/helpers/storage';
import { STORAGE_PREFIX } from '../constants';

class MisakeyUserManager extends UserManager {
  get userStorageKey() {
    return `${STORAGE_PREFIX}${this._userStoreKey}`;
  }

  // implement custom loads of silent renew access token when expiring
  // as library doesn't handle silent auth with cookie-stored access_token
  loadSilentAuthTimer(user) {
    if (!this.settings.automaticSilentRenew) {
      return;
    }

    if (!isNil(user.expires_in)) {
      const duration = user.expires_in;
      log(`Access token Expiring: remaining duration: ${duration}`);

      if (duration > 0) {
        // only register expiring if we still have time
        let expiring = duration - this._events._accessTokenExpiringNotificationTime;
        if (expiring <= 0) {
          expiring = 1;
        }

        log(`Registering expiring timer in: ${expiring}`);
        this._events._accessTokenExpiring.init(expiring);
      } else {
        log("Canceling existing expiring timer because we're past expiration.");
        this._events._accessTokenExpiring.cancel();
      }

      // if it's negative, it will still fire
      const expired = duration + 1;
      log(`Registering expired timer in: ${expired}`);
      this._events._accessTokenExpired.init(expired);
    } else {
      this._events._accessTokenExpiring.cancel();
      this._events._accessTokenExpired.cancel();
    }
  }

  // overrides UserManager method to fit with our backend architecture
  _signinStart(args, navigator, navigatorParams = {}) {
    return navigator.prepare(navigatorParams).then((handle) => {
      log('UserManager._signinStart: got navigator window handle');

      return this.createSigninRequest(args).then((signinRequest) => {
        log('UserManager._signinStart: got signin request');

        const nonce = uuid4RFC4122(); // Generates RFC4122 version 4 guid
        const referrer = args.referrer || `${window.location.pathname}${window.location.search || ''}${window.location.hash || ''}`;

        // We need to rework the request generated by the library as we use a backend redirect uri
        // which is a case not handled by oidc-client-js :
        //   - we add the nonce params to the request, as it will be checked by signInCallback
        //     method in case of an auth `token` request
        //   - we remove the code_challenge and the code_challenge method as there is no way for the
        //     backend to handle it for now (https://gitlab.misakey.dev/misakey/js-common/issues/61#note_231261546)
        const [baseUrl, params] = signinRequest.url.split('?');
        const searchParams = new URLSearchParams(params || '');
        searchParams.set('nonce', nonce);
        searchParams.delete('code_challenge');
        searchParams.delete('code_challenge_method');

        const newNavigatorParams = {
          ...navigatorParams,
          id: signinRequest.state.id,
          url: `${baseUrl}?${searchParams.toString()}`,
        };

        // We need to custom the object stored in the localStorage to:
        //  - add the nonce so the lib could validate it when the back will reply
        //  - add the referrer to redirect to the right route on backend response
        //  - remove the code_verifier to prevent the lib to wait for a code in the reply
        //  - remove the client_secret as it is use to processCode and we don't need to do it
        const signInState = signinRequest.state;
        // cannot use object destructuring as signinRequest.state is a Class
        const newSignInRequest = JSON.stringify({
          id: signInState.id,
          data: signInState.data,
          created: signInState.created,
          request_type: signInState.request_type,
          authority: signInState.authority,
          client_id: signInState.client_id,
          scope: signInState.scope,
          extraTokenParams: signInState.extraTokenParams,
          skipUserInfo: signInState.skipUserInfo,
          nonce,
          referrer,
          ...(args.acr_values ? { acr_values: args.acr_values } : {}),
        });

        // It can happen on Android Mobile WebView as domStorage are not enabled by default
        // https://stackoverflow.com/questions/5899087/android-webview-localstorage/5934650#5934650
        if (isNil(this.settings.stateStore._store)) {
          // check on oidc state is going to fail if storage is not available
          throw new StorageUnavailable();
        }

        return this.settings.stateStore.set(signinRequest.state.id, newSignInRequest)
          .then(() => handle.navigate(newNavigatorParams));
      }).catch((err) => {
        if (handle.close) {
          handle.close();
        }
        logSentryException(
          err,
          'UserManager._signinStart: Error after preparing navigator, closing navigator window',
          { auth: true },
        );
        throw err;
      });
    });
  }

  getUser() {
    try {
      return this._loadUser().then((user) => {
        if (user) {
          log('UserManager.getUser: user loaded');

          this._events.load(user, false);
          // Fire expiring handled on load user
          this.loadSilentAuthTimer(user);

          return user;
        }

        log('UserManager.getUser: user not found in storage');
        return null;
      });
    } catch (e) {
      logSentryException(e, 'UserManager.getUser: localStorage not available', { auth: true }, 'warning');
      return Promise.reject(new StorageUnavailable());
    }
  }
}

export default function createUserManager(config) {
  const { authority } = config;
  const userManagerConfig = {
    metadata: {
      issuer: `${authority}/`,
      jwks_uri: `${authority}/.well-known/jwks.json`,
      authorization_endpoint: `${authority}/oauth2/auth`,
      token_endpoint: `${authority}/oauth2/token`,
      userinfo_endpoint: `${authority}/userinfo`,
    },
    response_type: 'code',
    scope: 'openid tos privacy_policy',
    automaticSilentRenew: true,
    loadUserInfo: false,
    userStore: new WebStorageStateStore({ store: storage }),
    stateStore: new WebStorageStateStore({ store: sessionStorage }),
    ...config,
  };
  return new MisakeyUserManager(userManagerConfig);
}
